import { observable, computed, action } from "mobx";
import { Index } from "../packGameData/defs";
import { DB } from "./db/db";
import { GameWonProofs } from "./db/defs";
import { Player } from "../lib/qmplayer/player";
import { getLang } from "./lang";
import { CACHE_MUSIC_NAME_MP3, DATA_DIR, CACHE_IMAGES_NAME } from "./consts";
import firebase from "firebase";

type CacheInfo = "no" | "yes" | undefined;
interface CacheInstallInfo {
  sizeTotal: number;
  downloaded: number;
  currentFile: string;
}
export const QUEST_SEARCH_ALL = "all";
export const QUEST_SEARCH_OWN = "own";

/**
 * The BeforeInstallPromptEvent is fired at the Window.onbeforeinstallprompt handler
 * before a user is prompted to "install" a web site to a home screen on mobile.
 *
 * Only supported on Chrome and Android Webview.
 */
interface BeforeInstallPromptEvent extends Event {
  /**
   * Returns an array of DOMString items containing the platforms on which the event was dispatched.
   * This is provided for user agents that want to present a choice of versions to the user such as,
   * for example, "web" or "play" which would allow the user to chose between a web version or
   * an Android version.
   */
  readonly platforms: Array<string>;

  /**
   * Returns a Promise that resolves to a DOMString containing either "accepted" or "dismissed".
   */
  readonly userChoice: Promise<{
    outcome: "accepted" | "dismissed";
    platform: string;
  }>;

  /**
   * Allows a developer to show the install prompt at a time of their own choosing.
   * This method returns a Promise.
   */
  prompt(): Promise<void>;
}

export function splitByBuckets<T>(array: T[], amountOfBuckets: number) {
  // Implementation is generated by github copilot, lol
  const buckets: T[][] = [];
  for (let i = 0; i < amountOfBuckets; i++) {
    buckets.push([]);
  }
  array.forEach((item, index) => {
    buckets[index % amountOfBuckets].push(item);
  });
  return buckets;
}

// tslint:disable-next-line:no-useless-cast
const DOWNLOAD_AUDIBLE_MEDIA_KEYS = ["sound", "track"] as const;

export class Store {
  constructor(public index: Index, public app: firebase.app.App, public db: DB, player: Player) {
    window.addEventListener("hashchange", this.setPath);
    this.setPath();
    this.player = player;

    this.pwaAlreadyInstalled = window.matchMedia("(display-mode: standalone)").matches;
    window.addEventListener("beforeinstallprompt", (e) => {
      e.preventDefault();
      this.pwaInstallReadyEvent = e as BeforeInstallPromptEvent;
    });
    window.addEventListener("appinstalled", (evt) => {
      this.pwaAlreadyInstalled = true;
      this.installImagesCache().catch((e) => console.warn(e));
      this.installMusicCache().catch((e) => console.warn(e));
    });

    this.queryCacheInfo()
      .then(() => {
        if (this.pwaAlreadyInstalled) {
          if (this.imagesCache === "no") {
            this.installImagesCache().catch((e) => console.warn(e));
          }
          if (this.musicCache === "no") {
            this.installMusicCache().catch((e) => console.warn(e));
          }
        }
      })
      .catch((e) => console.warn(e));
  }

  @observable player: Player;

  private readonly setPath = () => {
    const hash = location.hash.replace(/^#/, "").replace(/^\//, "");
    if (this._hash === hash) {
      return;
    }
    this._hash = hash;
  };

  @observable pwaInstallReadyEvent?: BeforeInstallPromptEvent;
  @observable pwaAlreadyInstalled: boolean;

  @observable private _hash: string = "";

  @computed
  get hash() {
    return "#/" + this._hash;
  }
  @computed
  get path() {
    const arr = this._hash.split("/");
    return {
      tab0: arr[0],
      tab1: arr[1],
      tab2: arr[2],
    };
  }

  @observable firebaseLoggedIn: firebase.User | null | undefined = undefined;

  @observable firebaseSyncing: boolean = false;

  @computed
  get l() {
    return getLang(this.player.lang);
  }

  @observable wonProofs: Map<string, GameWonProofs | undefined> | undefined;

  async loadWinProofsFromLocal() {
    const m = new Map<string, GameWonProofs | undefined>();
    await Promise.all(
      this.index.quests.map(async (quest) => {
        const passed = await this.db.isGamePassedLocal(quest.gameName);
        m.set(quest.gameName, passed);
      }),
    );
    this.wonProofs = m;
  }

  async syncWithFirebase() {
    if (this.firebaseSyncing) {
      // TODO: retry sync when first finished
      return;
    }
    this.firebaseSyncing = true;
    await this.db.syncWithFirebase();

    // console.info: renew all cached values
    const player = await this.db.getConfigLocal("player");
    if (player) {
      this.player = player;
    }

    await this.loadWinProofsFromLocal();

    this.firebaseSyncing = false;
  }

  lastQuestListScroll: number = 0;

  @observable serviceWorkerRegistered: boolean = false;

  @observable serviceWorkerController: ServiceWorkerState | null = null;

  @observable reloadingPage: boolean = false;

  @observable storageIsPersisted: boolean | undefined = undefined;

  @observable installingServiceWorkerState: ServiceWorkerState | null = null;
  @observable waitingServiceWorkerState: ServiceWorkerState | null = null;
  @observable waitingServiceWorker: ServiceWorker | null = null;
  @observable activeServiceWorkerState: ServiceWorkerState | null = null;

  @observable questsListTab: string = QUEST_SEARCH_ALL;
  @observable questsListSearch: string = "";

  @observable imagesCache: CacheInfo;
  @observable imagesCacheInstallInfo: CacheInstallInfo | undefined;

  @observable musicCache: CacheInfo;
  @observable musicCacheInstallInfo: CacheInstallInfo | undefined;

  async queryCacheInfo() {
    // To remove use
    // await caches.keys().then(keys => Promise.all(keys.map(key => caches.delete(key))))
    //
    const cacheMusic = await caches.open(CACHE_MUSIC_NAME_MP3);
    let somethingMissingMusic = false;
    for (const key of DOWNLOAD_AUDIBLE_MEDIA_KEYS) {
      for (const f of this.index.dir[key].files) {
        if (!(await cacheMusic.match(DATA_DIR + f.filePath + f.fileName))) {
          somethingMissingMusic = true;
          break;
        }
      }
      if (somethingMissingMusic) {
        break;
      }
    }
    if (!this.musicCacheInstallInfo) {
      this.musicCache = somethingMissingMusic ? "no" : "yes";
    }

    const cacheImages = await caches.open(CACHE_IMAGES_NAME);
    let somethingMissingImages = false;
    for (const f of this.index.dir.images.files) {
      if (!(await cacheImages.match(DATA_DIR + f.filePath + f.fileName))) {
        somethingMissingImages = true;
        break;
      }
    }
    if (!this.imagesCacheInstallInfo) {
      this.imagesCache = somethingMissingImages ? "no" : "yes";
    }
  }
  async installMusicCache() {
    if (this.musicCacheInstallInfo) {
      return;
    }
    this.musicCacheInstallInfo = {
      currentFile: "",
      sizeTotal: DOWNLOAD_AUDIBLE_MEDIA_KEYS.map((key) => this.index.dir[key].totalSize).reduce(
        (acc, cur) => acc + cur,
        0,
      ),

      downloaded: 0,
    };
    const cacheMusic = await caches.open(CACHE_MUSIC_NAME_MP3);
    for (const key of DOWNLOAD_AUDIBLE_MEDIA_KEYS) {
      for (const f of this.index.dir[key].files) {
        this.musicCacheInstallInfo.currentFile = f.fileName;
        const url = DATA_DIR + f.filePath + f.fileName;
        const data = await fetch(url);
        await cacheMusic.put(url, data);
        this.musicCacheInstallInfo.downloaded += f.size;
      }
    }
    this.musicCache = "yes";
    this.musicCacheInstallInfo = undefined;
  }
  async installImagesCache() {
    if (this.imagesCacheInstallInfo) {
      return;
    }
    this.imagesCacheInstallInfo = {
      currentFile: "",
      sizeTotal: this.index.dir.images.totalSize,
      downloaded: 0,
    };
    const cacheImages = await caches.open(CACHE_IMAGES_NAME);

    const USE_PARALLEL_LOADING = true;

    if (USE_PARALLEL_LOADING) {
      const imagesCacheInstallInfo = this.imagesCacheInstallInfo;
      const DOWNLOADING_THREADS = 20;
      const filesBuckets = splitByBuckets(this.index.dir.images.files, DOWNLOADING_THREADS);
      await Promise.all(
        filesBuckets.map(async (filesBucket) => {
          for (const file of filesBucket) {
            const url = DATA_DIR + file.filePath + file.fileName;
            const data = await fetch(url);
            await cacheImages.put(url, data);
            imagesCacheInstallInfo.downloaded += file.size;
          }
        }),
      );
    } else {
      for (const f of this.index.dir.images.files) {
        this.imagesCacheInstallInfo.currentFile = f.fileName;
        const url = DATA_DIR + f.filePath + f.fileName;
        const data = await fetch(url);
        await cacheImages.put(url, data);
        this.imagesCacheInstallInfo.downloaded += f.size;
      }
    }
    this.imagesCache = "yes";
    this.imagesCacheInstallInfo = undefined;
  }
  async removeMusicCache() {
    if (this.musicCacheInstallInfo) {
      return;
    }
    await caches.delete(CACHE_MUSIC_NAME_MP3);
    this.musicCache = "no";
  }
  async removeImagesCache() {
    if (this.imagesCacheInstallInfo) {
      return;
    }
    await caches.delete(CACHE_IMAGES_NAME);
    this.imagesCache = "no";
  }

  @computed
  get defaultMusicList() {
    const trackFolderList = this.index.dir.track.files
      .filter((fileInfo) => fileInfo.useForRandomMusic)
      .map((fileInfo) => fileInfo.filePath + fileInfo.fileName);
    return trackFolderList;
  }
}

/*
- page is server by sw.js: true/false
- another installing
- another waiting

*/
